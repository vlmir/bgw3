package export

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/vlmir/bgw3/src/bgw"
	"github.com/vlmir/bgw3/src/semweb"
	"github.com/vlmir/bgw3/src/util"
	"os"
	"strings"
)

func checkE(e error) {
	if e != nil {
		panic(e)
	}
}

// GeneProt wrtes RDF files for genes (graph 'gene') and proteins (graph 'prot')
// Arguments:
// 1. data structure aggregating data from UniProt for a single taxon
// 2; path for writing 'gene' file
// e. path for writing 'prot' file
// 4. path for writing cross-references
// Retturns:
// number of lines written to 'gene' file
// number of lines written to 'prot' file
// error
func GeneProt(dat4rdf bgw.Dat4rdf, wpthG, wpthP, wpthX string) (int, int, error) {
	/*
	Fields in updat:
	Add("pome",pome)
	Add("come",come)
	Add("upid",cells[1])
	Add("spnm",cells[2])
	Add("txn",txid)
	Add("pdfn",strings.Replace(cells[4],"\"",",,",1))
	Add("pubmed",cells[6])
	Add("score",bits[0])
	*/
	// generated by parse.Updat()
	updat := *dat4rdf.Udat // util.Set3D, keys: Uniprot canonical accessions
	updat.Check()          // 8 linker keys:
	// generated by parse.Updat()
	txns := *dat4rdf.Txns // util.Set3D, taxonomic data
	if len(txns) != 1 {
		msg := fmt.Sprintf("TaxonUndefined")
		panic(errors.New(msg))
	}
	txn := txns.Keys()[0]
	// generated by parse.Upidmap()
	gnm2upca := *dat4rdf.Gnm // util.Set3D, keys: UniProt gene names
	gnm2upca.Check()         // 1 linker: "upac"
	// generated by parse.Upidmap()
	upac2xrf := *dat4rdf.Upac // util.Set3D, keys: UniProt accessions
	upac2xrf.Check()

	nss := rdf.Nss // BGW URI name spaces
	keys4g := make(util.SliceSet)
	// keys for object properties ('gene' graph)
	keys4g["Opys"] = []string{
		"gn2gp",
		"gn2txn",
		"mbr2lst",
		"sth2clm",
		"sth2ori",
		"sth2src",
		"sub2cls",
		"sub2set",
	}
	// keys for annotation properties ('gene' graph)
	keys4g["Apys"] = []string{
		"sth2dfn",
		"sth2lbl",
		"sth2syn",
	}
	// keys for parental classes ('gene' graph)
	keys4g["Prns"] = []string{
		"bag",
		"gn",
	}
	keys4p := make(util.SliceSet)
	// keys for object properties ('prot' graph)
	keys4p["Opys"] = []string{
		"gp2txn",
		"mbr2lst",
		"sth2clm",
		"sth2evd",
		"sth2ori",
		"sth2src",
		"sub2cls",
		"sub2set",
	}
	// keys for annotation properties ('prot' graph)
	keys4p["Apys"] = []string{
		"evd2lvl",
		"sth2dfn",
		"sth2lbl",
		"sth2syn",
	}
	// keys for parental classes ('prot' graph)
	keys4p["Prns"] = []string{
		"bag",
		"tlp",
	}
	nlng := 0 // number of lines 'gene' graph
	nlnp := 0 // number of lines 'prot' graph
	cnts := make(util.Set2D)
	cnts["txns"] = make(util.Set1D)  // taxon counts
	cnts["chrs"] = make(util.Set1D)  // chromosome counts
	cnts["bgwgs"] = make(util.Set1D) //gene counts
	cnts["bgwps"] = make(util.Set1D) // protein counts
	srcU := rdf.FormU(nss["uniprot"])
	graphUg := "<http://biogateway.eu/graph/gene>"
	graphUp := "<http://biogateway.eu/graph/prot>"
	dfn := "" // descriptor
	lbl := "" // short label
	/////////////////////////////////////////////////////////////////////////////
	wfhG, err := os.Create(wpthG)
	checkE(err)
	defer wfhG.Close()
	wfhP, err := os.Create(wpthP)
	checkE(err)
	defer wfhP.Close()
	// 'gene' graph ini
	var sbG strings.Builder
	gnUs := rdf.FmtURIs(keys4g) // URIs for 'gene' graph
	header, ng := rdf.Capita(keys4g)
	sbG.WriteString(header)
	nlng += ng
	sbG.WriteString(rdf.FormT(graphUg, gnUs["sth2src"], srcU))
	nlng++
	//srcUa = "<https://www.uniprot.org/uniprot/?query=organism:" + txn + "&columns=id,entry%20name,organism,organism-id,protein%20names,proteome,citation,annotation%20score&format=tab>"
	//sbG.WriteString(rdf.FormT("<http://biogateway.eu/graph/gene>", gnUs["sth2ori"], srcUa)); nlng++
	nsG := rdf.FormU(nss["gene"])
	sbG.WriteString(rdf.FormT(nsG, gnUs["sub2cls"], gnUs["bag"]))
	nlng++
	dfn = "Set of genes in Biogateway"
	sbG.WriteString(rdf.FormT(nsG, gnUs["sth2dfn"], rdf.FormL(dfn)))
	nlng++
	sbG.WriteString(rdf.FormT(nsG, gnUs["sth2lbl"], rdf.FormL("gene")))
	nlng++
	// prot graph ini
	var sbP strings.Builder
	gpUs := rdf.FmtURIs(keys4p) // URIs for 'prot' graph
	header, np := rdf.Capita(keys4p)
	sbP.WriteString(header)
	nlnp += np
	sbP.WriteString(rdf.FormT(graphUp, gpUs["sth2src"], srcU))
	nlnp++
	//srcUa = "<https://www.uniprot.org/uniprot/?query=organism:" + txn + "&columns=id,entry%20name,organism,organism-id,protein%20names,proteome,citation,annotation%20score&format=tab>"
	//sbP.WriteString(rdf.FormT("<http://biogateway.eu/graph/prot>", gpUs["sth2ori"], srcUa)); nlnp++
	nsP := rdf.FormU(nss["prot"])
	sbP.WriteString(rdf.FormT(nsP, gpUs["sub2cls"], gpUs["bag"]))
	nlnp++
	dfn = "Set of translation products in Biogateway"
	sbP.WriteString(rdf.FormT(nsP, gpUs["sth2dfn"], rdf.FormL(dfn)))
	nlnp++
	sbP.WriteString(rdf.FormT(nsP, gpUs["sth2lbl"], rdf.FormL("prot")))
	nlnp++
	/////////////////////////////////////////////////////////////////////////////
	upca2bgwg := make(util.Set3D)         // keys: UniProt canonical accessions
	bgwg2bgwp := make(util.Set3D)         // keys: BGW gene IDs
	spnm := txns[txn]["spnm"].Keys()[0]   // biological species name
	// removing alternative names:
	bits := strings.Split(spnm, "(")
	spnm = strings.TrimSpace(bits[0])
	txnU := rdf.CompU(nss["ncbitx"], txn) // taxon URI
	txnGU := rdf.CompU(nss["gene"], txn)  // BGW gene set URI
	sbG.WriteString(rdf.FormT(txnGU, gnUs["sub2cls"], gnUs["bag"]))
	nlng++
	sbG.WriteString(rdf.FormT(txnGU, gnUs["sub2set"], nsG))
	nlng++
	sbG.WriteString(rdf.FormT(txnGU, gnUs["gn2txn"], txnU))
	nlng++
	dfn = fmt.Sprintf("Set of %s genes in Biogateway", spnm)
	sbG.WriteString(rdf.FormT(txnGU, gnUs["sth2dfn"], rdf.FormL(dfn)))
	nlng++
	lbl = strings.Join([]string{"gene", txn}, "/")
	sbG.WriteString(rdf.FormT(txnGU, gnUs["sth2lbl"], rdf.FormL(lbl)))
	nlng++
	txnPU := rdf.CompU(nss["prot"], txn)
	sbP.WriteString(rdf.FormT(txnPU, gpUs["sub2cls"], gpUs["bag"]))
	nlnp++
	sbP.WriteString(rdf.FormT(txnPU, gpUs["sub2set"], nsP))
	nlnp++
	sbP.WriteString(rdf.FormT(txnPU, gpUs["gp2txn"], txnU))
	nlnp++
	dfn = fmt.Sprintf("Set of %s translation products in Biogateway", spnm)
	sbP.WriteString(rdf.FormT(txnPU, gpUs["sth2dfn"], rdf.FormL(dfn)))
	nlnp++
	lbl = strings.Join([]string{"prot", txn}, "/")
	sbP.WriteString(rdf.FormT(txnPU, gpUs["sth2lbl"], rdf.FormL(lbl)))
	nlnp++
	/////////////////////////////////////////////////////////////////////////////
	for chr := range txns[txn]["come"] {
		chrid := strings.Join([]string{txn, chr}, "/")
		chrGU := rdf.CompU(nss["gene"], chrid)
		chrPU := rdf.CompU(nss["prot"], chrid)
		sbG.WriteString(rdf.FormT(chrGU, gnUs["sub2cls"], gnUs["bag"]))
		nlng++
		sbG.WriteString(rdf.FormT(chrGU, gnUs["sub2set"], txnGU))
		nlng++
		dfn := fmt.Sprintf("Set of genes residing in %s %s", spnm, chr)
		sbG.WriteString(rdf.FormT(chrGU, gnUs["sth2dfn"], rdf.FormL(dfn)))
		nlng++
		lbl = strings.Join([]string{"gene", chrid}, "/")
		sbG.WriteString(rdf.FormT(chrGU, gnUs["sth2lbl"], rdf.FormL(lbl)))
		nlng++
		sbP.WriteString(rdf.FormT(chrPU, gpUs["sub2cls"], gpUs["bag"]))
		nlnp++
		sbP.WriteString(rdf.FormT(chrPU, gpUs["sub2set"], txnPU))
		nlnp++
		dfn = fmt.Sprintf("Set of tranlation products encoded by %s %s", spnm, chr)
		sbP.WriteString(rdf.FormT(chrPU, gpUs["sth2dfn"], rdf.FormL(dfn)))
		nlnp++
		lbl = strings.Join([]string{"prot", chrid}, "/")
		sbP.WriteString(rdf.FormT(chrPU, gpUs["sth2lbl"], rdf.FormL(lbl)))
		nlnp++
	}

	/////////////////////////////////////////////////////////////////////////////
	wfhX, err := os.Create(wpthX)
	checkE(err)
	defer wfhX.Close()
	xmap := bgw.NewXmap() // cross-references

	/////////////////////////////////////////////////////////////////////////////
	/// Genes ///
	// gnm2upca checked, the only use in the whole function
	for symG, mapG := range gnm2upca {
		mapG.Check()          // gnm2upac not empty
		upcas := mapG["upca"] // only canonical
		upcas.Check()         // upcas not empty
		for upca, _ := range upcas {
			xrfs, ok := upac2xrf[upca]
			if !ok {
				msg := fmt.Sprintf("export.GeneProt():%s:%s: NoXref", txn, upca)
				fmt.Printf("%s\n", msg)
				continue
			}
			m := 3 // at least "upac", "upca", "uparc" - SIC!
			if l := len(xrfs); l < m {
				msg := fmt.Sprintf("export.GeneProt():%s%s: TooFewDataFields", txn, upca)
				panic(errors.New(msg))
			} // all filds present and have at least one entry
			oriU := rdf.CompU(nss["uniprot"], upca)
			// All chromosemes associated with a particular UP accession:
			chrs := updat[upca]["come"].Keys()
			if len(chrs) == 0 {
				msg := fmt.Sprintf("export.GeneProt():%s:%s: ChromosomeUndefined", txn, upca) //22884 for 25 taxa
				fmt.Printf("%s\n", msg)
				continue
			}
			chr := chrs[0]
			if len(chrs) > 1 {
				// indeed multip chromosomes an a single UP entry
				// e.g.M0QZ52: 3 chromoomes, 3 Ensembk_PRO, 3 HGNC IDs, but SINGLE UniParc
				chr = "multi"
				// symG = upca
			}
			// for chr := range updat[upca]["come"] {
			chrid := strings.Join([]string{txn, chr}, "/")
			chrGU := rdf.CompU(nss["gene"], chrid)
			idG := strings.Join([]string{txn, chr, symG}, "/")
			upca2bgwg.Add(upca, "bgwg", idG)
			ourGU := rdf.CompU(nss["gene"], idG)
			sbG.WriteString(rdf.FormT(ourGU, gnUs["sub2cls"], gnUs["gn"]))
			nlng++
			sbG.WriteString(rdf.FormT(ourGU, gnUs["gn2txn"], txnU))
			nlng++
			sbG.WriteString(rdf.FormT(ourGU, gnUs["mbr2lst"], chrGU))
			nlng++
			dfn := fmt.Sprintf("Gene %s residing in %s %s", symG, spnm, chr)
			if chr == "multi" {
				dfn = fmt.Sprintf("Gene %s residing in %s multiple chromosomes", symG, spnm)
			}
			sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2dfn"], rdf.FormL(dfn)))
			nlng++
			sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2lbl"], rdf.FormL(symG)))
			nlng++
			/// gene synonyms ///
			gsnms := xrfs["gsnm"]
			for gsnm := range gsnms {
				if gsnm == symG {
					continue
				}
				sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2syn"], rdf.FormL(gsnm)))
				nlng++
			}
			sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2ori"], oriU))
			nlng++
			/// id mapping ///
			// multiple BGW GeneIDs per GeneName are possible, e.g.:
			//<http://rdf.biogateway.eu/gene/9606/multi/CALM1>
			// <http://rdf.biogateway.eu/gene/9606/chr-14/CALM1>
			xmap.Gsymb.Add(symG, "bgwg", idG)
			xmap.Gsymb.Add(idG, "gnm", symG)
			ensgs := xrfs["ensg"]
			for ensg := range ensgs {
				ensgU := rdf.CompU(nss["ensg"], ensg)
				sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2clm"], ensgU))
				nlng++
				xmap.Ensg.Add(ensg, "bgwg", idG)
				xmap.Bgwg.Add(idG, "ensg", ensg)
			}
			ncbigs := xrfs["ncbig"]
			for ncbig := range ncbigs {
				ncbigU := rdf.CompU(nss["ncbig"], ncbig)
				sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2clm"], ncbigU))
				nlng++
				xmap.Ncbig.Add(ncbig, "bgwg", idG)
				xmap.Bgwg.Add(idG, "ncbig", ncbig)
			}
			// }
		}
	} // end of gene
	/////////////////////////////////////////////////////////////////////////////
	/// Proteins ///
	for upca, onemap := range updat {
		xrfs, ok := upac2xrf[upca]
		if !ok {
			msg := fmt.Sprintf("export.GeneProt():%s:%s: NoXrfs", txn, upca)
			fmt.Printf("%s\n", msg)
			continue
		}
		if len(onemap) < 8 {
			msg := fmt.Sprintf("export.GeneProt():%s:%s: TooFewDataFields", txn, upca)
			fmt.Printf("%s\n", msg)
			continue
		} // all filds present and have at least one entry
		gnms := xrfs["gnm"].Keys()
		l := len(gnms) // sic!
		if l == 0 {    // 219695 in 25 taxa - why so many? TODO
			msg := fmt.Sprintf("export.GeneProt():%s:%s: NoGeneName", txn, upca)
			fmt.Printf("%s\n", msg)
			continue
		}
		lblP := gnms[0] // MUST stay here!
		if l > 1 {      // 267 in 25 taxa; max 24!
			// sort.Strings(gnms)
			msg := fmt.Sprintf("export.GeneProt():%s:%s: %d GeneNames: %v", txn, upca, l, gnms)
			fmt.Printf("%s\n", msg)
			lblP = upca
		}
		// lblP := strings.Join(gnms, "!")
		gsnms := xrfs["gsnm"].Keys()
		for _, gnm := range gnms {
			gsnms = append(gsnms, gnm)
		}

		// removing alternative definitions:
		bits := strings.Split(onemap["pdfn"].Keys()[0], "(")
		pdfn := strings.TrimSpace(bits[0])
		if len(pdfn) == 0 {
			msg := fmt.Sprintf("export.GeneProt():%s:%s: NoDefinition", txn, upca)
			fmt.Printf("%s\n", msg)
			pdfn = "Unspecified" // 90 in 25 species
		}
		score := onemap["score"].Keys()[0]
		pubmeds := strings.Split(onemap["pubmed"].Keys()[0], "; ")
		idGs := upca2bgwg[upca]["bgwg"] // constructed above, no isoforms herein
		if l := len(idGs); l > 1 {
			msg := fmt.Sprintf("export.GeneProt():%s:%s: %d GeneIDs: %v", txn, upca, l, idGs.Keys())
			fmt.Printf("%s\n", msg)
		}
		upids := onemap["upid"].Keys()
		oriU := rdf.CompU(nss["uniprot"], upca)
		for idG := range idGs { // there is at least one
			bagU := rdf.CompU(nss["prot"], idG)
			bits := strings.Split(idG, "/")
			chr := bits[1]
			symG := bits[2]
			chrid := strings.Join([]string{txn, chr}, "/")
			chrPU := rdf.CompU(nss["prot"], chrid)
			sbP.WriteString(rdf.FormT(bagU, gpUs["sub2cls"], gpUs["bag"]))
			nlnp++
			sbP.WriteString(rdf.FormT(bagU, gpUs["sub2set"], chrPU))
			nlnp++
			dfn := fmt.Sprintf("Set of tranlation products encoded by gene %s residing in %s %s", symG, spnm, chr)
			if chr == "multi" {
				dfn = fmt.Sprintf("Set of tranlation products encoded by gene %s residing in %s muliple chromosomes", symG, spnm)
			}
			sbP.WriteString(rdf.FormT(bagU, gpUs["sth2dfn"], rdf.FormL(dfn)))
			nlnp++
			sbP.WriteString(rdf.FormT(bagU, gpUs["sth2lbl"], rdf.FormL(idG)))
			nlnp++
			sbP.WriteString(rdf.FormT(bagU, gpUs["sth2ori"], oriU))
			nlnp++

			for upac := range xrfs["upac"] {
				canonical := false
				bits := strings.Split(upac, "-") // sic!
				if len(bits) == 1 {
					canonical = true
				}
				uparcs := upac2xrf[upac]["uparc"].Keys() // normally strictly one per UPAC
				if l := len(uparcs); l != 1 {            // happens!! 82 in 25 taxa
					msg := fmt.Sprintf("export.GeneProt():%s:%s: %d UpArcs: %v", txn, upac, l, uparcs)
					fmt.Printf("%s\n", msg)
					continue
				}
				idP := fmt.Sprintf("%s%s%s", idG, "/", uparcs[0])
				if canonical {
					bgwg2bgwp.Add(idG, "bgwp", idP)
				}
				ourPU := rdf.CompU(nss["prot"], idP)
				sbP.WriteString(rdf.FormT(ourPU, gpUs["sub2cls"], gpUs["tlp"]))
				nlnp++
				sbP.WriteString(rdf.FormT(ourPU, gpUs["mbr2lst"], bagU))
				nlnp++
				sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2dfn"], rdf.FormL(pdfn)))
				nlnp++
				if canonical {
					sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2lbl"], rdf.FormL(lblP)))
				} else {
					sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2lbl"], rdf.FormL(upac)))
				}
				nlnp++
				// synonyms
				psnms := append(gsnms, upac, upids[0])
				for _, psnm := range psnms {
					if psnm == lblP {
						continue
					}
					if canonical {
						sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2syn"], rdf.FormL(psnm)))
						nlnp++
					}
				}
				sbP.WriteString(rdf.FormT(ourPU, gpUs["gp2txn"], txnU))
				nlnp++
				sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2ori"], oriU))
				nlnp++
				if canonical {
					sbP.WriteString(rdf.FormT(ourPU, gpUs["evd2lvl"], rdf.FormL(string(score))))
					nlnp++ // conversion needed?
				}
				for _, pubmed := range pubmeds {
					if pubmed == "" {
						msg := fmt.Sprintf("export.GeneProt():%s:%s: NoPubMed", txn, upac)
						fmt.Printf("%s\n", msg)
						continue
					} // TODO see why this occurs
					pubmedU := rdf.CompU(nss["pubmed"], pubmed)
					if canonical {
						sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2evd"], pubmedU))
						nlnp++
					}
				}
				/// id mapping ///
				// NB: multiple ENSPs and even NPs per UPAC are common
				xmap.Upac.Add(upac, "bgwp", idP)
				xmap.Bgwp.Add(idP, "upac", upac)
				ensps := upac2xrf[upac]["ensp"]
				for ensp := range ensps {
					enspU := rdf.CompU(nss["ensp"], ensp)
					sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2clm"], enspU))
					nlnp++
					xmap.Ensp.Add(ensp, "bgwp", idP)
					xmap.Bgwp.Add(idP, "ensp", ensp)
				}
				rfsqs := upac2xrf[upac]["rfsq"]
				for rfsq := range rfsqs {
					rfsqU := rdf.CompU(nss["rfsq"], rfsq)
					sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2clm"], rfsqU))
					nlnp++
					xmap.Rfsq.Add(rfsq, "bgwp", idP)
					xmap.Bgwp.Add(idP, "rfsq", rfsq)
				}
			} // end of upac2xrf
		} // end of idGs
	} // end of prot
	/////////////////////////////////////////////////////////////////////////////
	// gene -> prot relations
	for idG, idPmap := range bgwg2bgwp {
		ourGU := rdf.CompU(nss["gene"], idG)
		for idP := range idPmap["bgwp"] {
			ourPU := rdf.CompU(nss["prot"], idP)
			sbG.WriteString(rdf.FormT(ourGU, gnUs["gn2gp"], ourPU))
			nlng++ // NB: => gene graph
		}
	}
	/////////////////////////////////////////////////////////////////////////////
	wfhG.Write([]byte(sbG.String()))
	sbG.Reset()
	wfhP.Write([]byte(sbP.String()))
	sbP.Reset()
	// xmap export
	j, err := json.MarshalIndent(&xmap, "", " ")
	checkE(err)
	wfhX.Write(j)
	/////////////////////////////////////////////////////////////////////////////
	return nlng, nlnp, nil
} // end of GeneProt

// Note: no isoforms in this graph
func Gene2phen(duos, gsym2bgw util.Set3D, wpth string) (int, error) {
	nss := rdf.Nss // BGW URI name spaces
	nln := 0
	src := "uniprot"
	srcU := rdf.FormU(nss[src])
	if len(srcU) == 0 {
		msg := fmt.Sprintf("export.Gene2phen():UnknownNamespace: %s", src)
		panic(errors.New(msg))
	}
	keys4b := make(util.SliceSet)
	keys4b["Opys"] = []string{
		"gp2phn",
		"ins2cls",
		"sth2ori",
		"sth2src",
		"sub2cls",
	}
	keys4b["Apys"] = []string{
		"sth2dfn",
		"sth2lbl",
	}
	keys4b["Prns"] = []string{
		"stm",
	}
	// gene2phen graph ini
	wfh, err := os.Create(wpth)
	if err != nil {
		panic(err)
	}
	defer wfh.Close()
	var sb strings.Builder
	ourUs := rdf.FmtURIs(keys4b)
	header, n := rdf.Capita(keys4b)
	sb.WriteString(header)
	nln += n
	graphU := "<http://biogateway.eu/graph/gene2phen>"
	sb.WriteString(rdf.FormT(graphU, ourUs["sth2src"], srcU))
	nln++
	myori := "ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/variants/humsavar.txt"
	oriU := rdf.FormU(myori)
	sb.WriteString(rdf.FormT(graphU, ourUs["sth2ori"], oriU))
	nln++
	wfh.Write([]byte(sb.String()))
	sb.Reset()

	stmNS := "http://rdf.biogateway.eu/gene-phen/"
	rdfNS := nss["rdf"]
	count := make(util.Set3D)
	txn := "9606"

	for clsid, onemap := range duos {
		bits := strings.Split(clsid, "--")
		idL := bits[0]
		idR := bits[1]
		oriL := strings.Split(idL, "!")[1] // Gene Name
		bgwLs := gsym2bgw[oriL]["bgwg"].Keys()
		if len(bgwLs) == 0 {
			msg := fmt.Sprintf("export.Gene2phen:%s:%s: NoGeneIDs", txn, oriL)
			panic(errors.New(msg)) // 9606:0
		}
		oriR := strings.Split(idR, "!")[1]
		clsU := rdf.CompU(stmNS, clsid)
		sb.WriteString(rdf.FormT(clsU, ourUs["sub2cls"], ourUs["stm"]))
		nln++
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2lbl"], rdf.FormL(clsid)))
		nln++
		nmRs := onemap["nmR"].Keys()
		// multiple labels// indeed multiple names in the source
		for _, nmR := range nmRs {
			if len(nmRs) > 1 {
				count.Add("oriR", oriR, nmR)
			} // 9606:68
		}
		clsdfn := fmt.Sprintf("Association between gene %s and disease : %s", oriL, nmRs[0])
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2dfn"], rdf.FormL(clsdfn)))
		nln++

		pdc := "gp2phn"
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "predicate"), ourUs[pdc]))
		nln++
		uriR := rdf.CompU(nss["omim"], oriR)
		// multiple subjects
		for _, bgwL := range bgwLs {
			if len(bgwLs) > 1 {
				count.Add("oriL", oriL, bgwL)
			} // 9606:11
			uriL := rdf.CompU(nss["gene"], bgwL)
			sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "subject"), uriL))
			nln++
			sb.WriteString(rdf.FormT(uriL, ourUs[pdc], uriR))
			nln++
		}
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "object"), uriR))
		nln++
		insid := fmt.Sprintf("%s%s%s", clsid, "#", src)
		insU := rdf.CompU(stmNS, insid)
		sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], clsU))
		nln++
		sb.WriteString(rdf.FormT(insU, ourUs["sth2src"], srcU))
		nln++
		// metadata
		upcas := onemap["upca"].Keys()
		upca := upcas[0]
		myU := rdf.CompU(nss["uniprot"], upca)
		sb.WriteString(rdf.FormT(insU, ourUs["sth2ori"], myU))
		nln++
	}
	wfh.Write([]byte(sb.String()))
	sb.Reset()
	return nln, nil
} // end of Gene2phen

// arg1: output of parse.Gaf or parse.Gpa
// arg2: mapping fromn UniProt accession to BGW IDs generated by GeneProt()
// arg3: path for exporting the RDF file
func Goa(duos, upac2bgw util.Set3D, wpth string) (int, error) {
	nss := rdf.Nss // BGW URI name spaces
	/*
		Attn: isoforms are present in gpa files but lost in rdf files TODO !!
		~/g/g/s/b/prot2onto (master ⚡ → =)> cut -f 2 p53.gpa | grep P04637 | sort -u | wc -l
		8
	*/
	gosubs := map[string]string{
		"gp2cc": "cellular component",
		"gp2mf": "molecular function",
		"gp2bp": "biological process",
	}
	srcU := rdf.FormU(nss["goa"])
	keys4b := make(util.SliceSet)
	keys4b["Opys"] = []string{
		"gp2bp",
		"gp2cc",
		"gp2mf",
		"ins2cls",
		"sth2evd",
		"sth2mtd",
		"sth2ori",
		"sth2src",
		"sub2cls",
	}
	keys4b["Apys"] = []string{
		"sth2dfn",
		"sth2lbl",
	}
	keys4b["Prns"] = []string{
		"stm",
	}
	// prot2onto graph ini
	nln := 0
	wfh, err := os.Create(wpth)
	checkE(err)
	defer wfh.Close()
	var sb strings.Builder
	ourUs := rdf.FmtURIs(keys4b)
	header, n := rdf.Capita(keys4b)
	sb.WriteString(header)
	nln += n
	graphU := "<http://biogateway.eu/graph/prot2onto>"
	sb.WriteString(rdf.FormT(graphU, ourUs["sth2src"], srcU))
	nln++
	/*
		myori := "https://www.ebi.ac.uk/QuickGO/services/annotation/downloadSearch?taxonId=" + "9606" // TODO implement
		oriU := rdf.FormU(myori)
		sb.WriteString(rdf.FormT(graphU, ourUs["sth2ori"], oriU)); nln++
	*/
	wfh.Write([]byte(sb.String()))
	sb.Reset()

	stmNS := "http://rdf.biogateway.eu/prot-onto/"
	rdfNS := nss["rdf"]
	count := make(util.Set3D)

	for clsid, onemap := range duos {
		ppys := onemap["ppy"].Keys()
		if l := len(ppys); l != 1 { // unnecessary, may help debugging
			msg := fmt.Sprintf("export.Goa():%s: Want 1 property have: %d: %v", clsid, l, ppys)
			panic(errors.New(msg))
		}
		refs := onemap["ref"].Keys()
		/// Class level
		clsU := rdf.CompU(stmNS, clsid)
		sb.WriteString(rdf.FormT(clsU, ourUs["sub2cls"], ourUs["stm"]))
		nln++
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2lbl"], rdf.FormL(clsid)))
		nln++

		bits := strings.Split(clsid, "--")
		idL := bits[0]
		idR := bits[1]
		oriL := strings.Split(idL, "!")[1] // UP AC
		oriR := strings.Split(idR, "!")[1] // GO ID
		bgwLs := upac2bgw[oriL]["bgwp"].Keys()

		pdc := ppys[0]
		oboid := strings.Replace(oriR, "_", ":", 1)
		clsdfn := fmt.Sprintf("Association between protein %s and %s %s", oriL, gosubs[pdc], oboid)
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2dfn"], rdf.FormL(clsdfn)))
		nln++
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "predicate"), ourUs[pdc]))
		nln++

		uriR := rdf.CompU(nss["obo"], oriR)
		// multiple subjects
		for _, bgwL := range bgwLs {
			if len(bgwLs) > 1 {
				count.Add("oriL", oriL, bgwL)
			}
			uriL := rdf.CompU(nss["prot"], bgwL)
			sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "subject"), uriL))
			nln++
			sb.WriteString(rdf.FormT(uriL, ourUs[pdc], uriR))
			nln++
		}
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "object"), uriR))
		nln++
		/// Instance level
		insid := fmt.Sprintf("%s%s%s", clsid, "#", "goa")
		insU := rdf.CompU(stmNS, insid)
		sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], clsU))
		nln++
		sb.WriteString(rdf.FormT(insU, ourUs["sth2src"], srcU))
		nln++
		// metadata
		myU := rdf.CompU(nss["goa"], oriL)
		sb.WriteString(rdf.FormT(insU, ourUs["sth2ori"], myU))
		nln++
		for _, ref := range util.X1type(refs, "pubmed", "!") {
			myU := rdf.CompU(nss["pubmed"], ref)
			sb.WriteString(rdf.FormT(insU, ourUs["sth2evd"], myU))
			nln++
		}
		for _, eco := range onemap["eco"].Keys() { // for GPA files
			myU := rdf.CompU(nss["obo"], eco)
			sb.WriteString(rdf.FormT(insU, ourUs["sth2mtd"], myU))
			nln++
		}
		for _, goc := range onemap["goc"].Keys() { // for GAF files
			sb.WriteString(rdf.FormT(insU, ourUs["sth2mtd"], rdf.FormL(goc)))
			nln++
		}
	}
	wfh.Write([]byte(sb.String()))
	sb.Reset()
	return nln, nil
}

func Mitab(duos, upac2bgw util.Set3D, wpth string) (int, error) {
	nss := rdf.Nss // BGW URI name spaces
	keys4b := make(util.SliceSet)
	keys4b["Opys"] = []string{
		"ins2cls",
		"sth2evd",
		"sth2mtd",
		"sth2src",
		"tlp2tlp",
		"sub2cls",
		"sub2set",
	}
	keys4b["Apys"] = []string{
		"evd2lvl",
		"sth2dfn",
		"sth2lbl",
	}
	keys4b["Prns"] = []string{
		"stm",
	}
	srcU := rdf.FormU(nss["intact"])
	// prot2prot graph ini
	nln := 0
	wfh, err := os.Create(wpth)
	checkE(err)
	defer wfh.Close()
	var sb strings.Builder
	ourUs := rdf.FmtURIs(keys4b)
	header, n := rdf.Capita(keys4b)
	sb.WriteString(header)
	nln += n
	graphU := "<http://biogateway.eu/graph/prot2prot>"
	sb.WriteString(rdf.FormT(graphU, ourUs["sth2src"], srcU))
	nln++
	/*
		myori := "http://www.ebi.ac.uk/Tools/webservices/psicquic/intact/webservices/current/search/query/species:" + "9606" // TODO implement
		oriU := rdf.FormU(myori)
		sb.WriteString(rdf.FormT(graphU, ourUs["sth2ori"], oriU)); nln++
	*/
	wfh.Write([]byte(sb.String()))
	sb.Reset()

	stmNS := "http://rdf.biogateway.eu/prot-prot/"
	rdfNS := nss["rdf"]
	count := make(util.Set3D)
	for clsid, onemap := range duos {
		refs := onemap["pubids"].Keys()
		refs = util.X1type(refs, "pubmed", ":")

		clsU := rdf.CompU(stmNS, clsid)
		sb.WriteString(rdf.FormT(clsU, ourUs["sub2cls"], ourUs["stm"]))
		nln++
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2lbl"], rdf.FormL(clsid)))
		nln++
		bits := strings.Split(clsid, "--")
		idL := bits[0]
		idR := bits[1]
		oriL := strings.Split(idL, "!")[1] // UP AC
		oriR := strings.Split(idR, "!")[1] // UP AC
		clsdfn := fmt.Sprintf("Pair of molecular interactors %s and %s", oriL, oriR)
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2dfn"], rdf.FormL(clsdfn)))
		nln++
		pdc := "tlp2tlp"
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "predicate"), ourUs[pdc]))
		nln++
		bgwLs := upac2bgw[oriL]["bgwp"].Keys()
		bgwRs := upac2bgw[oriR]["bgwp"].Keys()
		// multiple subjects and objects
		// 53 human UP ACs with multiple BGW IDs
		for _, bgwL := range bgwLs {
			if len(bgwLs) > 1 {
				count.Add("oriL", oriL, bgwL)
			}
			uriL := rdf.CompU(nss["prot"], bgwL)
			sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "subject"), uriL))
			nln++
			for _, bgwR := range bgwRs {
				if len(bgwRs) > 1 {
					count.Add("oriR", oriR, bgwR)
				}
				uriR := rdf.CompU(nss["prot"], bgwR)
				sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "object"), uriR))
				nln++
				sb.WriteString(rdf.FormT(uriL, ourUs[pdc], uriR))
				nln++
				sb.WriteString(rdf.FormT(uriR, ourUs[pdc], uriL))
				nln++
			}
		}
		insid := fmt.Sprintf("%s%s%s", clsid, "#", "intact")
		insU := rdf.CompU(stmNS, insid)
		sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], clsU))
		nln++
		sb.WriteString(rdf.FormT(insU, ourUs["sth2src"], srcU))
		nln++
		/// metadata, aggregated for all subjects and objects
		/// intaracton IDs
		for key := range onemap["inacids"] {
			bits := strings.Split(key, ":")
			if bits[0] != "intact" {
				continue
			}
			myU := rdf.CompU(nss["intact"], bits[1])
			//sb.WriteString(rdf.FormT(insU, ourUs["sth2ori"], myU))
			sb.WriteString(rdf.FormT(insU, ourUs["sub2set"], myU)) // Attn: change prop
			nln++
		}
		/// publications
		// TODO use this patter for all?
		for _, item := range refs {
			myU := rdf.CompU(nss["pubmed"], item)
			sb.WriteString(rdf.FormT(insU, ourUs["sth2evd"], myU))
			nln++
		}
		/// confidence values
		for key := range onemap["cnfvals"] {
			bits := strings.Split(key, ":")
			if bits[0] != "intact-miscore" {
				continue
			}
			sb.WriteString(rdf.FormT(insU, ourUs["evd2lvl"], rdf.FormL(bits[1])))
			nln++
		}
		/// interaction types
		for key := range onemap["inactps"] {
			bits := strings.Split(key, "\"")
			if bits[0] != "psi-mi:" {
				continue
			}
			myU := rdf.CompU(nss["obo"], strings.Replace(bits[1], ":", "_", 1))
			sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], myU))
			nln++
		}
		/// detection methods
		for key := range onemap["mtds"] {
			bits := strings.Split(key, "\"")
			if bits[0] != "psi-mi:" {
				continue
			}
			myU := rdf.CompU(nss["obo"], strings.Replace(bits[1], ":", "_", 1))
			sb.WriteString(rdf.FormT(insU, ourUs["sth2mtd"], myU))
			nln++
		}
	}
	wfh.Write([]byte(sb.String()))
	sb.Reset()
	return nln, nil
}

// Tfac2gene wrtes an RDF file for relations between transcription factors (TF) and target genes (TG);
// taxonomic coverage defined by arguments 2 and 3
// Arguments:
// 1. map aggregating data from one external source
// 2. map TF ID (currently UniProt Accession) -> -> BGW protein ID
// 3. map Gene Symbol -> -> BGW gene ID
// 4. data source map label -> URI, currently a SINGLE source, one of:
// cytreg  extri  geredb  goa  htri  intact  signor  tfacts  trrust
// 5; path for writing 'tfac2gene' file
// Retturns:
// 1. number of lines written to the output RDF file
// 2. error
func Tfac2gene(dat4txn map[string]util.Set3D, upac2bgw, gsym2bgw util.Set3D, wpth string) (int, error) {
	// Note: no isoforms in this graph
	nss := rdf.Nss // BGW URI name spaces
	keys4b := make(util.SliceSet)
	keys4b["Opys"] = []string{
		"ins2cls",
		"sth2src",
		"sub2cls",
		"rgr2trg",
		"sth2evd",
	}
	keys4b["Apys"] = []string{
		"sth2dfn",
		"sth2lbl",
		"evd2lvl",
		"sth2val",
	}
	keys4b["Prns"] = []string{
		"stm",
	}
	// trrust: Activation|Repression|Unknown
	// cytreg: Activation|Repression
	// geredb: positive|negative|unknown
	// goa: UP|DOWN|GO:XXXXXXX
	// signor: UP|DOWN|Unknown
	// tfacts: UP|DOWN
	// should be 'positive' or 'negative'
	modes := map[string]string{
		"Activation": "Positive",
		"Repression": "Negative",
		"UP":         "Positive",
		"DOWN":       "Negative",
		"positive":   "Positive",
		"negative":   "Negative",
	}
	// tfac2gene graph ini
	nln := 0
	wfh, err := os.Create(wpth)
	checkE(err)
	defer wfh.Close()
	var sb strings.Builder
	ourUs := rdf.FmtURIs(keys4b)
	header, n := rdf.Capita(keys4b)
	sb.WriteString(header)
	nln += n
	graphU := "<http://biogateway.eu/graph/tfac2gene>"
	wfh.Write([]byte(sb.String())) // nln:27
	sb.Reset()
	///////////////////////////////////////////////////////////////////////////////

	stmNS := "http://rdf.biogateway.eu/tfac-gene/"
	rdfNS := nss["rdf"]
	for src, duos := range dat4txn {
		uri := duos[src]["uri"].Keys()[0]
		srcU := rdf.FormU(uri)
		sb.WriteString(rdf.FormT(graphU, ourUs["sth2src"], srcU))
		nln++
		for clsid, duo := range duos {
			if clsid == src {
				continue
			}
			clsU := rdf.CompU(stmNS, clsid)
			sb.WriteString(rdf.FormT(clsU, ourUs["sub2cls"], ourUs["stm"]))
			nln++
			sb.WriteString(rdf.FormT(clsU, ourUs["sth2lbl"], rdf.FormL(clsid)))
			nln++

			bits := strings.Split(clsid, "--")
			gsymL := bits[0]
			gsymR := bits[1]
			clsdfn := fmt.Sprintf("Regulation of gene %s by transcription factor %s", gsymR, gsymL)
			sb.WriteString(rdf.FormT(clsU, ourUs["sth2dfn"], rdf.FormL(clsdfn)))
			nln++
			pdc := "rgr2trg"
			sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "predicate"), ourUs[pdc]))
			nln++                          // nln:31
			oriLs := duo["uniprot"].Keys() // UniProt canonical accessions
			//if len(oriLs) != 1 // only NFKB and AP1
			// multiple BGW genes due to multiple GeneSymbols for a single UP ACC
			bgwRs := gsym2bgw[gsymR]["bgwg"].Keys() // GeneSymbols
			//if len(bgwRs) != 1 // 9606:1110
			for _, oriL := range oriLs {
				bgwLs := upac2bgw[oriL]["bgwp"].Keys()
				//if len(bgwLs) = 0 // 9606:14, 13 unique; only 3 UP ACCs: P62805, P69905, Q16385
				if len(bgwLs) != 1 {
					msg := fmt.Sprintf("export.Tfac2gene():%s:%s: %d ProtIDs ", gsymL, oriL, len(bgwLs))
					fmt.Printf("%s\n", msg)
				} // 9606:25 unique accessions no BGW protein, e.g.Q9NRY4, present in idmapping
				for _, bgwL := range bgwLs {
					uriL := rdf.CompU(nss["prot"], bgwL)
					sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "subject"), uriL))
					nln++
					for _, bgwR := range bgwRs {
						uriR := rdf.CompU(nss["gene"], bgwR)
						sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "object"), uriR))
						nln++
						sb.WriteString(rdf.FormT(uriL, ourUs[pdc], uriR))
						nln++

						//for src, uri := range srcs {
						insid := fmt.Sprintf("%s%s%s", clsid, "#", src)
						insU := rdf.CompU(stmNS, insid)
						meta := "pubmed"
						keys := duo[meta].Keys() // PubMed  IDs
						if len(keys) == 0 {
							msg := fmt.Sprintf("export.Tfac2gene():%s: NoPubMedIDs ", clsid)
							fmt.Printf("%s\n", msg)
							continue
						}
						sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], clsU))
						nln++
						sb.WriteString(rdf.FormT(insU, ourUs["sth2src"], srcU))
						nln++
						// Cleaning up the mess in the data file: PubMed ID: \d+
						for _, key := range keys {
							if key[0] < 48 || key[0] > 57 {
								continue
							}
							pubmedU := rdf.CompU(nss["pubmed"], key)
							sb.WriteString(rdf.FormT(insU, ourUs["sth2evd"], pubmedU))
							nln++
						}
						meta = "confidence"
						keys = duo[meta].Keys() // confidence levels
						for _, key := range keys {
							sb.WriteString(rdf.FormT(insU, ourUs["evd2lvl"], rdf.FormL(key)))
							nln++
						}
						meta = "mode"
						keys = duo[meta].Keys() // regulation mode
						for _, key := range keys {
							val, ok := modes[key]
							if !ok {
								continue
							}
							sb.WriteString(rdf.FormT(insU, ourUs["sth2val"], rdf.FormL(val)))
							nln++
						}
						//}

					} // bgwRs
				} // bgwLs
			} // oriLs
		} // duos
	} // srcs
	wfh.Write([]byte(sb.String()))
	sb.Reset()
	return nln, nil
}

// Note: no isoforms in this graph
func Ortho(duos, upac2bgw util.Set3D, wpth string) (int, error) {
	nss := rdf.Nss // BGW URI name spaces
	keys4b := make(util.SliceSet)
	keys4b["Opys"] = []string{
		"orl2orl",
		"ins2cls",
		"sth2src",
		"sub2cls",
		"sub2set",
	}
	keys4b["Apys"] = []string{
		"sth2dfn",
		"sth2lbl",
	}
	keys4b["Prns"] = []string{
		"stm",
	}
	// ortho graph ini
	nln := 0
	wfh, err := os.Create(wpth)
	checkE(err)
	defer wfh.Close()
	var sb strings.Builder
	ourUs := rdf.FmtURIs(keys4b)
	header, _ := rdf.Capita(keys4b)
	//header, _ := rdf.Header(ourUs, keys4b)
	sb.WriteString(header)
	//nln += n
	graphU := "<http://biogateway.eu/graph/ortho>"
	srcU := rdf.FormU(nss["uniprot"])
	sb.WriteString(rdf.FormT(graphU, ourUs["sth2src"], srcU))
	//nln++
	wfh.Write([]byte(sb.String()))
	sb.Reset()
	///////////////////////////////////////////////////////////////////////////////
	stmNS := "http://rdf.biogateway.eu/ortho/"
	rdfNS := nss["rdf"]
	idmkeys := bgw.Orthokeys
	for clsid, duo := range duos {
		clsU := rdf.CompU(stmNS, clsid)
		bits := strings.Split(clsid, "--")
		oriL := strings.Split(bits[0], "!")[1] // UniProt Accession
		oriR := strings.Split(bits[1], "!")[1] // UniProt Accession
		bgwLs := upac2bgw[oriL]["bgwp"].Keys()
		bgwRs := upac2bgw[oriR]["bgwp"].Keys()
		if len(bgwLs) == 0 {
			msg := fmt.Sprintf("export.Ortho():%s: NoProtID", oriL)
			fmt.Printf("%s\n", msg)
			continue
		}
		if len(bgwRs) == 0 {
			msg := fmt.Sprintf("export.Ortho():%s: NoProtID", oriR)
			fmt.Printf("%s\n", msg)
			continue
		}
		sb.WriteString(rdf.FormT(clsU, ourUs["sub2cls"], ourUs["stm"]))
		nln++
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2lbl"], rdf.FormL(clsid)))
		nln++
		clsdfn := fmt.Sprintf("Pair of orthologous proteins %s and %s", oriL, oriR)
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2dfn"], rdf.FormL(clsdfn)))
		nln++
		pdc := "orl2orl"
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "predicate"), ourUs[pdc]))
		nln++
		// multiple subjects and objects
		// 53 human UP ACs with multiple BGW IDs
		for _, bgwL := range bgwLs {
			uriL := rdf.CompU(nss["prot"], bgwL)
			sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "subject"), uriL))
			nln++
			for _, bgwR := range bgwRs {
				uriR := rdf.CompU(nss["prot"], bgwR)
				sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "object"), uriR))
				nln++
				sb.WriteString(rdf.FormT(uriL, ourUs[pdc], uriR))
				nln++
				sb.WriteString(rdf.FormT(uriR, ourUs[pdc], uriL))
				nln++
			}
		}
		for key, sets := range duo {
			src := idmkeys[key]
			insid := fmt.Sprintf("%s%s%s", clsid, "#", src)
			insU := rdf.CompU(stmNS, insid)
			sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], clsU))
			nln++
			srcU := rdf.FormU(nss[src])
			sb.WriteString(rdf.FormT(insU, ourUs["sth2src"], srcU))
			nln++
			for setid, _ := range sets {
				prefix := ""
				if key == "OrthoDB" {
					prefix = "?query="
				}
				lastbit := fmt.Sprintf("%s%s", prefix, setid)
				setU := rdf.FormU(fmt.Sprintf("%s%s", nss[src], lastbit))
				sb.WriteString(rdf.FormT(insU, ourUs["sub2set"], setU))
				nln++
			}
		}
		wfh.Write([]byte(sb.String()))
		sb.Reset()
	}
	return nln, nil
}
