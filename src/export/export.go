package export

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/vlmir/bgw3/src/bgw"
	"github.com/vlmir/bgw3/src/semweb"
	"github.com/vlmir/bgw3/src/util"
	"os"
	"sort"
	"strings"
)

func checkE(e error) {
	if e != nil {
		panic(e)
	}
}

// GeneProt wrtes RDF files for genes (graph 'gene') and proteins (graph 'prot')
// Arguments:
// 1. data structure aggregating data from UniProt for a single taxon
// 2; path for writing 'gene' file
// e. path for writing 'prot' file
// 4. path for writing cross-references
// Retturns:
// number of lines written to 'gene' file
// number of lines written to 'prot' file
// error
func GeneProt(dat4rdf bgw.Dat4rdf, wpthG, wpthP, wpthX string) (int, int, error) {
	/*
	Fields in updat:
	Add("pome",pome)
	Add("come",come)
	Add("upid",cells[1])
	Add("spnm",cells[2])
	Add("txid",txid)
	Add("pdfn",strings.Replace(cells[4],"\"",",,",1))
	Add("pubmed",cells[6])
	Add("score",bits[0])
	*/
	// generated by parse.Updat()
	updat := *dat4rdf.Udat // util.Set3D, keys: Uniprot canonical accessions
	updat.Check()          // 8 linker keys:
	// generated by parse.Updat()
	taxa := *dat4rdf.Txns // util.Set3D, taxonomic data
	if len(taxa) != 1 {
		msg := fmt.Sprintf("TaxonUndefined")
		panic(errors.New(msg))
	}
	txid := taxa.Keys()[0]
	genes := *dat4rdf.Gnm // util.Set3D, keys: UniProt gene names
	genes.Check()         // 2 linkers: "upac", "gsnm"
	// generated by parse.Upidmap()
	upac2xrf := *dat4rdf.Upac // util.Set3D, keys: UniProt accessions
	upac2xrf.Check()

	nss := rdf.Nss // BGW URI name spaces
	keys4g := make(util.SliceSet)
	// keys for object properties ('gene' graph)
	keys4g["Opys"] = []string{
		"gn2gp",
		"gn2txn",
		"mbr2lst",
		"sth2clm",
		"sth2ori",
		"sth2src",
		"sub2cls",
		"sub2set",
	}
	// keys for annotation properties ('gene' graph)
	keys4g["Apys"] = []string{
		"sth2dfn",
		"sth2lbl",
		"sth2syn",
	}
	// keys for parental classes ('gene' graph)
	keys4g["Prns"] = []string{
		"bag",
		"gn",
	}
	keys4p := make(util.SliceSet)
	// keys for object properties ('prot' graph)
	keys4p["Opys"] = []string{
		"gp2txn",
		"mbr2lst",
		"sth2clm",
		"sth2evd",
		"sth2ori",
		"sth2src",
		"sub2cls",
		"sub2set",
	}
	// keys for annotation properties ('prot' graph)
	keys4p["Apys"] = []string{
		"evd2lvl",
		"sth2dfn",
		"sth2lbl",
		"sth2syn",
	}
	// keys for parental classes ('prot' graph)
	keys4p["Prns"] = []string{
		"bag",
		"tlp",
	}
	nlng := 0 // number of lines 'gene' graph
	nlnp := 0 // number of lines 'prot' graph
	cnts := make(util.Set2D)
	cnts["taxa"] = make(util.Set1D)  // taxon counts
	cnts["chrs"] = make(util.Set1D)  // chromosome counts
	cnts["bgwgs"] = make(util.Set1D) //gene counts
	cnts["bgwps"] = make(util.Set1D) // protein counts
	srcU := rdf.FormU(nss["uniprot"])
	graphUg := "<http://biogateway.eu/graph/gene>"
	graphUp := "<http://biogateway.eu/graph/prot>"
	dfn := "" // descriptor
	lbl := "" // short label
	/////////////////////////////////////////////////////////////////////////////
	wfhG, err := os.Create(wpthG)
	checkE(err)
	defer wfhG.Close()
	wfhP, err := os.Create(wpthP)
	checkE(err)
	defer wfhP.Close()
	// 'gene' graph ini
	var sbG strings.Builder
	gnUs := rdf.FmtURIs(keys4g) // URIs for 'gene' graph
	header, ng := rdf.Capita(keys4g)
	sbG.WriteString(header)
	nlng += ng
	sbG.WriteString(rdf.FormT(graphUg, gnUs["sth2src"], srcU))
	nlng++
	//srcUa = "<https://www.uniprot.org/uniprot/?query=organism:" + txid + "&columns=id,entry%20name,organism,organism-id,protein%20names,proteome,citation,annotation%20score&format=tab>"
	//sbG.WriteString(rdf.FormT("<http://biogateway.eu/graph/gene>", gnUs["sth2ori"], srcUa)); nlng++
	nsG := rdf.FormU(nss["gene"])
	sbG.WriteString(rdf.FormT(nsG, gnUs["sub2cls"], gnUs["bag"]))
	nlng++
	dfn = "Set of genes in Biogateway"
	sbG.WriteString(rdf.FormT(nsG, gnUs["sth2dfn"], rdf.FormL(dfn)))
	nlng++
	sbG.WriteString(rdf.FormT(nsG, gnUs["sth2lbl"], rdf.FormL("gene")))
	nlng++
	// prot graph ini
	var sbP strings.Builder
	gpUs := rdf.FmtURIs(keys4p) // URIs for 'prot' graph
	header, np := rdf.Capita(keys4p)
	sbP.WriteString(header)
	nlnp += np
	sbP.WriteString(rdf.FormT(graphUp, gpUs["sth2src"], srcU))
	nlnp++
	//srcUa = "<https://www.uniprot.org/uniprot/?query=organism:" + txid + "&columns=id,entry%20name,organism,organism-id,protein%20names,proteome,citation,annotation%20score&format=tab>"
	//sbP.WriteString(rdf.FormT("<http://biogateway.eu/graph/prot>", gpUs["sth2ori"], srcUa)); nlnp++
	nsP := rdf.FormU(nss["prot"])
	sbP.WriteString(rdf.FormT(nsP, gpUs["sub2cls"], gpUs["bag"]))
	nlnp++
	dfn = "Set of translation products in Biogateway"
	sbP.WriteString(rdf.FormT(nsP, gpUs["sth2dfn"], rdf.FormL(dfn)))
	nlnp++
	sbP.WriteString(rdf.FormT(nsP, gpUs["sth2lbl"], rdf.FormL("prot")))
	nlnp++
	/////////////////////////////////////////////////////////////////////////////
	upca2bgwg := make(util.Set3D)         // keys: UniProt canonical accessions
	bgwg2bgwp := make(util.Set3D)         // keys: BGW gene IDs
	spnm := taxa[txid]["spnm"].Keys()[0]   // biological species name
	// removing alternative names:
	bits := strings.Split(spnm, "(")
	spnm = strings.TrimSpace(bits[0])
	txnU := rdf.CompU(nss["ncbitx"], txid) // taxon URI
	txnGU := rdf.CompU(nss["gene"], txid)  // BGW gene set URI
	sbG.WriteString(rdf.FormT(txnGU, gnUs["sub2cls"], gnUs["bag"]))
	nlng++
	sbG.WriteString(rdf.FormT(txnGU, gnUs["sub2set"], nsG))
	nlng++
	sbG.WriteString(rdf.FormT(txnGU, gnUs["gn2txn"], txnU))
	nlng++
	dfn = fmt.Sprintf("Set of %s genes in Biogateway", spnm)
	sbG.WriteString(rdf.FormT(txnGU, gnUs["sth2dfn"], rdf.FormL(dfn)))
	nlng++
	lbl = strings.Join([]string{"gene", txid}, "/")
	sbG.WriteString(rdf.FormT(txnGU, gnUs["sth2lbl"], rdf.FormL(lbl)))
	nlng++
	txnPU := rdf.CompU(nss["prot"], txid)
	sbP.WriteString(rdf.FormT(txnPU, gpUs["sub2cls"], gpUs["bag"]))
	nlnp++
	sbP.WriteString(rdf.FormT(txnPU, gpUs["sub2set"], nsP))
	nlnp++
	sbP.WriteString(rdf.FormT(txnPU, gpUs["gp2txn"], txnU))
	nlnp++
	dfn = fmt.Sprintf("Set of %s translation products in Biogateway", spnm)
	sbP.WriteString(rdf.FormT(txnPU, gpUs["sth2dfn"], rdf.FormL(dfn)))
	nlnp++
	lbl = strings.Join([]string{"prot", txid}, "/")
	sbP.WriteString(rdf.FormT(txnPU, gpUs["sth2lbl"], rdf.FormL(lbl)))
	nlnp++
	if nlng < 35 || nlnp < 37 {
		msg := fmt.Sprintf("MalformedHeader")
		panic(errors.New(msg))
	}
	nlng = 0
	nlnp = 0
	/////////////////////////////////////////////////////////////////////////////
	chrs := taxa[txid]["come"].Keys()
	for _, chr := range chrs {
	//for chr := range taxa[txid]["come"] {
		chrid := strings.Join([]string{txid, chr}, "/")
		chrGU := rdf.CompU(nss["gene"], chrid)
		chrPU := rdf.CompU(nss["prot"], chrid)
		sbG.WriteString(rdf.FormT(chrGU, gnUs["sub2cls"], gnUs["bag"]))
		nlng++
		sbG.WriteString(rdf.FormT(chrGU, gnUs["sub2set"], txnGU))
		nlng++
		dfn := fmt.Sprintf("Set of genes residing in %s %s", spnm, chr)
		sbG.WriteString(rdf.FormT(chrGU, gnUs["sth2dfn"], rdf.FormL(dfn)))
		nlng++
		lbl = strings.Join([]string{"gene", chrid}, "/")
		sbG.WriteString(rdf.FormT(chrGU, gnUs["sth2lbl"], rdf.FormL(lbl)))
		nlng++
		sbP.WriteString(rdf.FormT(chrPU, gpUs["sub2cls"], gpUs["bag"]))
		nlnp++
		sbP.WriteString(rdf.FormT(chrPU, gpUs["sub2set"], txnPU))
		nlnp++
		dfn = fmt.Sprintf("Set of tranlation products encoded by %s %s", spnm, chr)
		sbP.WriteString(rdf.FormT(chrPU, gpUs["sth2dfn"], rdf.FormL(dfn)))
		nlnp++
		lbl = strings.Join([]string{"prot", chrid}, "/")
		sbP.WriteString(rdf.FormT(chrPU, gpUs["sth2lbl"], rdf.FormL(lbl)))
		nlnp++
	}
	/////////////////////////////////////////////////////////////////////////////
	wfhX, err := os.Create(wpthX)
	checkE(err)
	defer wfhX.Close()
	xmap := bgw.NewXmap() // cross-references

	/////////////////////////////////////////////////////////////////////////////
	/// Genes ///
	// genes checked, the only use in the whole function
	// genes: ALL GeneNams in the Reference Protome!
	symGs := genes.Keys()
	for _, symG := range symGs {
	//for symG, mapG := range genes {
		mapG, ok := genes[symG]
		if !ok {continue}
		// symG == UniProtID for entries with multiple GeneNames now
		if symG == "" {continue} // TODO see why this happens
		mapG.Check()          // not empty
		upcas := mapG["upca"].Keys()
		// canonical accessions for a gene, filter by Reference Proteome in parse.Updat:
		//upcas.Check()         // not empty
		for _, upca := range upcas {
			xrfs, ok := upac2xrf[upca]
			if !ok {
				// never happens
				msg := fmt.Sprintf("export.GeneProt():%s:%s: NoXref", txid, upca)
				fmt.Printf("%s\n", msg)
				continue
			}
			m := 3 // at least "upac", "upca", "uparc" - SIC!
			if l := len(xrfs); l < m {
				// never happens
				msg := fmt.Sprintf("export.GeneProt():%s:%s: TooFewDataFields", txid, upca)
				panic(errors.New(msg))
			} // all fields present and have at least one entry
			ensgs := xrfs["ensg"].Keys()
			ncbigs := xrfs["ncbig"].Keys()
			if len(ensgs) + len(ncbigs) == 0 {
				msg := fmt.Sprintf("export.GeneProt():%s:%s:%s: NoGeneXref, skipped", txid, symG, upca)
				fmt.Printf("%s\n", msg)
				continue
			} // skipping genes without xrefs; 44691 in the 25 taxa
			onedat, ok := updat[upca]
			// skipping accessions filtered out in parse.Updat():
			if !ok {continue}// probably redundant
			upid := onedat["upid"].Keys()[0]
			oriU := rdf.CompU(nss["uniprot"], upca)
			// All chromosemes associated with a particular UP accession:
			// there is at least one in updat
			chrs := onedat["come"].Keys()
			chr := chrs[0]
			if len(chrs) > 1 {
				// indeed multiple chromosomes an a single UP entry
				// e.g.M0QZ52: 3 chromoomes, 3 Ensembk_PRO, 3 HGNC IDs, but SINGLE UniParc
				// UP000005640: Chromosome 14, UP000005640: Chromosome 19, UP000005640: Chromosome 2
				// NB: only Chromosome 19 2020-05-23 download
				chr = fmt.Sprintf("multi-%s", upca)
			}
			idG := strings.Join([]string{txid, chr, symG}, "/")
			upca2bgwg.Add(upca, "bgwg", idG)
			ourGU := rdf.CompU(nss["gene"], idG)
			sbG.WriteString(rdf.FormT(ourGU, gnUs["sub2cls"], gnUs["gn"]))
			nlng++
			sbG.WriteString(rdf.FormT(ourGU, gnUs["gn2txn"], txnU))
			nlng++
			for _, chr := range chrs { // SIC!
				chrid := strings.Join([]string{txid, chr}, "/")
				chrGU := rdf.CompU(nss["gene"], chrid)
				sbG.WriteString(rdf.FormT(ourGU, gnUs["mbr2lst"], chrGU))
				nlng++
			}
			dfn := fmt.Sprintf("Gene %s residing in %s %s", symG, spnm, chr)
			if len(chrs) > 1 || symG == upid {
				dfn = fmt.Sprintf("Set of genes encoding %s protein in %s", symG, spnm)
			}
			sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2dfn"], rdf.FormL(dfn)))
			nlng++
			sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2lbl"], rdf.FormL(symG)))
			nlng++
			/// gene synonyms ///
			gsnms := mapG["gsnm"].Keys()
			// includes original GeneNames for entries with multipls GeneNames for now
			for _, gsnm := range gsnms {
				if gsnm == symG {
					continue
				}
				if gsnm == "" {
					continue
				}// TODO see why this happens
				sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2syn"], rdf.FormL(gsnm)))
				nlng++
			}
			sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2ori"], oriU))
			nlng++
			/// id mapping ///
			// multiple BGW GeneIDs per GeneName are possible, e.g.:
			//<http://rdf.biogateway.eu/gene/9606/multi/CALM1>
			// <http://rdf.biogateway.eu/gene/9606/chr-14/CALM1>
			xmap.Gsymb.Add(symG, "bgwg", idG)
			xmap.Gsymb.Add(idG, "gnm", symG)
			for _, ensg := range ensgs {
				ensgU := rdf.CompU(nss["ensg"], ensg)
				sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2clm"], ensgU))
				nlng++
				xmap.Ensg.Add(ensg, "bgwg", idG)
				xmap.Bgwg.Add(idG, "ensg", ensg)
			}
			for _, ncbig := range ncbigs {
				ncbigU := rdf.CompU(nss["ncbig"], ncbig)
				sbG.WriteString(rdf.FormT(ourGU, gnUs["sth2clm"], ncbigU))
				nlng++
				xmap.Ncbig.Add(ncbig, "bgwg", idG)
				xmap.Bgwg.Add(idG, "ncbig", ncbig)
			}
			// }
		}
	} // end of gene
	/////////////////////////////////////////////////////////////////////////////
	/// Proteins ///
	upcas := updat.Keys()
	for _, upca := range upcas {
		onedat, ok := updat[upca]
		if !ok {continue}
	//for upca, onedat := range updat {
		xrfs, ok := upac2xrf[upca]
		if !ok {
			// never happens
			msg := fmt.Sprintf("export.GeneProt():%s:%s: NoXrfs", txid, upca)
			fmt.Printf("%s\n", msg)
			continue
		}
		if len(onedat) < 10 {
			// never happens
			msg := fmt.Sprintf("export.GeneProt():%s:%s: TooFewDataFields", txid, upca)
			fmt.Printf("%s\n", msg)
			continue
		} // all filds present and have at least one entry
		gnms := onedat["gnm"].Keys()// justifiable way
		l := len(gnms)
		if l == 0 {
			// 219749 unique accessions in 25 taxa - why so many? TODO
			// 721 in 9606, 179 in 10090, 17642 in 3702 of 41597 total
			// NB: For entries with at least one gene xref NONE!!
			msg := fmt.Sprintf("export.GeneProt():%s:%s: NoGeneName", txid, upca)
			fmt.Printf("%s\n", msg)
			continue
		}
		upid := onedat["upid"].Keys()[0]
		/*
		if l > 1 {
			// 267 accessions in 25 taxa;
			// max 24 GeneNames in 7227 for P02283 (His2B), P02299 (His3), P84040 (His4)
			// P04745  AMY1_HUMAN      AMY1A; AMY1B; AMY1C: single Chr  UP000005640: Chromosome 1
			msg := fmt.Sprintf("export.GeneProt():%s:%s: %d GeneNames: %v", txid, upca, l, gnms)
			fmt.Printf("%s\n", msg)
		}
		*/
		/// protein synonyms
		// not really correct TODO
		/*
		psnms := onedat["gsnm"].Keys()
		for _, gnm := range gnms {
			psnms = append(psnms, gnm)
		}
		*/

		// removing alternative definitions:
		bits := strings.Split(onedat["pdfn"].Keys()[0], "(")
		pdfn := strings.TrimSpace(bits[0])
		if len(pdfn) == 0 {
			// 86 in 25 taxa
			msg := fmt.Sprintf("export.GeneProt():%s:%s: NoDefinition", txid, upca)
			fmt.Printf("%s\n", msg)
			pdfn = "Unspecified" // 90 in 25 species
		}
		score := onedat["score"].Keys()[0]
		pubmeds := strings.Split(onedat["pubmed"].Keys()[0], "; ")
		sort.Strings(pubmeds)
		// upca2bgwg constructed above, no isoforms herein
		idGs := upca2bgwg[upca]["bgwg"].Keys()
		if l := len(idGs); l > 1 {
			// 267 in 25 taxa
			msg := fmt.Sprintf("export.GeneProt():%s:%s: %d BgwGeneIDs: %v", txid, upca, l, idGs)
			fmt.Printf("%s\n", msg)
		}
		oriU := rdf.CompU(nss["uniprot"], upca)
		for _, idG := range idGs { // there should be exactly 1 as of 2020-06-04
			bagU := rdf.CompU(nss["prot"], idG)
			bits := strings.Split(idG, "/")
			chr := bits[1]
			if chr == "" {continue}
			symG := bits[2]
			if symG == "" {continue}
			chrid := strings.Join([]string{txid, chr}, "/")
			chrPU := rdf.CompU(nss["prot"], chrid)
			sbP.WriteString(rdf.FormT(bagU, gpUs["sub2cls"], gpUs["bag"]))
			nlnp++
			sbP.WriteString(rdf.FormT(bagU, gpUs["sub2set"], chrPU))
			nlnp++
			dfn := fmt.Sprintf("Set of tranlation products encoded by gene %s residing in %s %s", symG, spnm, chr)
			bits = strings.Split(chr, "-")
			if bits[0] == "multi" || symG == upid {
				dfn = fmt.Sprintf("Set of tranlation products encoded by gene %s in %s", symG, spnm)
			}
			sbP.WriteString(rdf.FormT(bagU, gpUs["sth2dfn"], rdf.FormL(dfn)))
			nlnp++
			sbP.WriteString(rdf.FormT(bagU, gpUs["sth2lbl"], rdf.FormL(idG)))
			nlnp++
			sbP.WriteString(rdf.FormT(bagU, gpUs["sth2ori"], oriU))
			nlnp++

			// iso-forms
			// xrfs - all xrefs for one accession
			upacs := xrfs["upac"].Keys() // canonical plus iso-forms
			for _, upac := range upacs {
				canonical := false
				lblP := ""
				bits := strings.Split(upac, "-") // sic!
				if len(bits) == 1 {
					canonical = true
				}
				if canonical {
					lblP = symG // MUST stay here!!!
				}
				uparcs := upac2xrf[upac]["uparc"].Keys()
				if l := len(uparcs); l != 1 {
					// 107 in 25 taxa TODO
					msg := fmt.Sprintf("export.GeneProt():%s:%s: %d UpArcs: %v, skipped", txid, upac, l, uparcs)
					fmt.Printf("%s\n", msg)
					continue
				}
				idP := fmt.Sprintf("%s%s%s", idG, "/", uparcs[0])
				if canonical {
					bgwg2bgwp.Add(idG, "bgwp", idP)
				}
				ourPU := rdf.CompU(nss["prot"], idP)
				sbP.WriteString(rdf.FormT(ourPU, gpUs["sub2cls"], gpUs["tlp"]))
				nlnp++
				sbP.WriteString(rdf.FormT(ourPU, gpUs["mbr2lst"], bagU))
				nlnp++
				sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2dfn"], rdf.FormL(pdfn)))
				nlnp++
				if canonical {
					sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2lbl"], rdf.FormL(lblP)))
					nlnp++
				}
				// synonyms
				var psnms []string// per upac
				if canonical {
					psnms = append(psnms, upac, upid)
				} else {
					psnms = append(psnms, upac)
				}
				for _, psnm := range psnms {
					if psnm == "" {
						continue
					}// TODO see why this happans
					if psnm == lblP {
						continue
					}// canonical accession with multiple GeneNames
					sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2syn"], rdf.FormL(psnm)))
					nlnp++
				}
				sbP.WriteString(rdf.FormT(ourPU, gpUs["gp2txn"], txnU))
				nlnp++
				sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2ori"], oriU))
				nlnp++
				if canonical {
					sbP.WriteString(rdf.FormT(ourPU, gpUs["evd2lvl"], rdf.FormL(string(score))))
					nlnp++ // conversion needed?
				}
				for _, pubmed := range pubmeds {
					if pubmed == "" {
						// 343938 in 25 taxa
						if canonical {
							msg := fmt.Sprintf("export.GeneProt():%s:%s: NoPubMed", txid, upac)
							fmt.Printf("%s\n", msg)
						}
						continue
					} // TODO see why this occurs
					pubmedU := rdf.CompU(nss["pubmed"], pubmed)
					if canonical {
						sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2evd"], pubmedU))
						nlnp++
					}
				}
				/// id mapping ///
				// NB: multiple ENSPs and even NPs per UPAC are common
				xmap.Upac.Add(upac, "bgwp", idP)
				xmap.Bgwp.Add(idP, "upac", upac)
				ensps := upac2xrf[upac]["ensp"].Keys()
				for _, ensp := range ensps {
					enspU := rdf.CompU(nss["ensp"], ensp)
					sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2clm"], enspU))
					nlnp++
					xmap.Ensp.Add(ensp, "bgwp", idP)
					xmap.Bgwp.Add(idP, "ensp", ensp)
				}
				rfsqs := upac2xrf[upac]["rfsq"].Keys()
				for _, rfsq := range rfsqs {
					rfsqU := rdf.CompU(nss["rfsq"], rfsq)
					sbP.WriteString(rdf.FormT(ourPU, gpUs["sth2clm"], rfsqU))
					nlnp++
					xmap.Rfsq.Add(rfsq, "bgwp", idP)
					xmap.Bgwp.Add(idP, "rfsq", rfsq)
				}
			} // end of upac2xrf
		} // end of idGs
	} // end of prot
	for idP, xrefs := range xmap.Bgwp {
		upacs := xrefs["upac"].Keys()
		if l := len(upacs); l > 1 {
			msg := fmt.Sprintf("export.GeneProt():%s: %d UniProtAccessions: %v", idP, l, upacs)
			fmt.Printf("%s\n", msg)
		}// 20200531 download: 21321 in 25 taxa, 10495 in 9606

	}
	/////////////////////////////////////////////////////////////////////////////
	// gene -> prot relations
	idGs := bgwg2bgwp.Keys()
	for _, idG := range idGs {
		idPmap := bgwg2bgwp[idG]
	//for idG, idPmap := range bgwg2bgwp {
		ourGU := rdf.CompU(nss["gene"], idG)
		idPs := idPmap["bgwp"].Keys()
		for _, idP := range idPs {
		//for idP := range idPmap["bgwp"] {
			ourPU := rdf.CompU(nss["prot"], idP)
			sbG.WriteString(rdf.FormT(ourGU, gnUs["gn2gp"], ourPU))
			nlng++ // NB: => gene graph
		}
	}
	/////////////////////////////////////////////////////////////////////////////
	wfhG.Write([]byte(sbG.String()))
	sbG.Reset()
	wfhP.Write([]byte(sbP.String()))
	sbP.Reset()
	// xmap export
	j, err := json.MarshalIndent(&xmap, "", " ")
	checkE(err)
	wfhX.Write(j)
	/////////////////////////////////////////////////////////////////////////////
	return nlng, nlnp, nil
} // end of GeneProt

// Note: no isoforms in this graph
func Gene2phen(duos, gsym2bgw util.Set3D, wpth string) (int, error) {
	nss := rdf.Nss // BGW URI name spaces
	nln := 0
	src := "uniprot"
	srcU := rdf.FormU(nss[src])
	if len(srcU) == 0 {
		msg := fmt.Sprintf("export.Gene2phen():UnknownNamespace: %s", src)
		panic(errors.New(msg))
	}
	keys4b := make(util.SliceSet)
	keys4b["Opys"] = []string{
		"gp2phn",
		"ins2cls",
		"sth2ori",
		"sth2src",
		"sub2cls",
	}
	keys4b["Apys"] = []string{
		"sth2vrs",
		"sth2dfn",
		"sth2lbl",
	}
	keys4b["Prns"] = []string{
		"stm",
	}
	// gene2phen graph ini
	wfh, err := os.Create(wpth)
	if err != nil {
		panic(err)
	}
	defer wfh.Close()
	var sb strings.Builder
	ourUs := rdf.FmtURIs(keys4b)
	header, n := rdf.Capita(keys4b)
	sb.WriteString(header)
	nln += n
	graphU := "<http://biogateway.eu/graph/gene2phen>"
	sb.WriteString(rdf.FormT(graphU, ourUs["sth2src"], srcU))
	nln++
	myori := "ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/variants/humsavar.txt"
	oriU := rdf.FormU(myori)
	sb.WriteString(rdf.FormT(graphU, ourUs["sth2ori"], oriU))
	nln++
	if nln < 18 {
		msg := fmt.Sprintf("MalformedHeader")
		panic(errors.New(msg))
	}
	nln = 0

	stmNS := "http://rdf.biogateway.eu/gene-phen/"
	rdfNS := nss["rdf"]
	count := make(util.Set3D)
	txid := "9606"

	for clsid, onemap := range duos {
		bits := strings.Split(clsid, "--")
		idL := bits[0]
		idR := bits[1]
		oriL := strings.Split(idL, "!")[1] // Gene Name
		bgwLs := gsym2bgw[oriL]["bgwg"].Keys()
		if len(bgwLs) == 0 {
			msg := fmt.Sprintf("export.Gene2phen:%s:%s: NoGeneIDs", txid, oriL)
			panic(errors.New(msg)) // 9606:0
		}
		oriR := strings.Split(idR, "!")[1]
		clsU := rdf.CompU(stmNS, clsid)
		sb.WriteString(rdf.FormT(clsU, ourUs["sub2cls"], ourUs["stm"]))
		nln++
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2lbl"], rdf.FormL(clsid)))
		nln++
		nmRs := onemap["nmR"].Keys()
		// multiple labels// indeed multiple names in the source
		for _, nmR := range nmRs {
			if len(nmRs) > 1 {
				count.Add("oriR", oriR, nmR)
			} // 9606:68
		}
		clsdfn := fmt.Sprintf("Association between gene %s and disease : %s", oriL, nmRs[0])
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2dfn"], rdf.FormL(clsdfn)))
		nln++

		pdc := "gp2phn"
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "predicate"), ourUs[pdc]))
		nln++
		uriR := rdf.CompU(nss["omim"], oriR)
		// multiple subjects
		for _, bgwL := range bgwLs {
			if len(bgwLs) > 1 {
				count.Add("oriL", oriL, bgwL)
			} // 9606:11
			uriL := rdf.CompU(nss["gene"], bgwL)
			sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "subject"), uriL))
			nln++
			sb.WriteString(rdf.FormT(uriL, ourUs[pdc], uriR))
			nln++
		}
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "object"), uriR))
		nln++
		insid := fmt.Sprintf("%s%s%s", clsid, "#", src)
		insU := rdf.CompU(stmNS, insid)
		sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], clsU))
		nln++
		sb.WriteString(rdf.FormT(insU, ourUs["sth2src"], srcU))
		nln++
		// metadata
		upcas := onemap["upca"].Keys()
		upca := upcas[0]
		myU := rdf.CompU(nss["uniprot"], upca)
		sb.WriteString(rdf.FormT(insU, ourUs["sth2ori"], myU))
		nln++
	}
	wfh.Write([]byte(sb.String()))
	sb.Reset()
	return nln, nil
} // end of Gene2phen

// arg1: output of parse.Gaf or parse.Gpa
// arg2: mapping fromn UniProt accession to BGW IDs generated by GeneProt()
// arg3: path for exporting the RDF file
func Prot2go(duos, upac2bgw util.Set3D, wpth string) (int, error) {
	nss := rdf.Nss // BGW URI name spaces
	/*
		Attn: isoforms are present in gpa files but lost in rdf files TODO !!
		~/g/g/s/b/prot2onto (master ⚡ → =)> cut -f 2 p53.gpa | grep P04637 | sort -u | wc -l
		8
	*/
	gosubs := map[string]string{
		"gp2cc": "cellular component",
		"gp2mf": "molecular function",
		"gp2bp": "biological process",
	}
	srcU := rdf.FormU(nss["goa"])
	keys4b := make(util.SliceSet)
	keys4b["Opys"] = []string{
		"gp2bp",
		"gp2cc",
		"gp2mf",
		"ins2cls",
		"sth2evd",
		"sth2mtd",
		"sth2ori",
		"sth2src",
		"sub2cls",
	}
	keys4b["Apys"] = []string{
		"sth2dfn",
		"sth2lbl",
	}
	keys4b["Prns"] = []string{
		"stm",
	}
	// prot2onto graph ini
	nln := 0
	wfh, err := os.Create(wpth)
	checkE(err)
	defer wfh.Close()
	var sb strings.Builder
	ourUs := rdf.FmtURIs(keys4b)
	header, n := rdf.Capita(keys4b)
	sb.WriteString(header)
	nln += n
	graphU := "<http://biogateway.eu/graph/prot2onto>"
	sb.WriteString(rdf.FormT(graphU, ourUs["sth2src"], srcU))
	nln++
	/*
		myori := "https://www.ebi.ac.uk/QuickGO/services/annotation/downloadSearch?taxonId=" + "9606" // TODO implement
		oriU := rdf.FormU(myori)
		sb.WriteString(rdf.FormT(graphU, ourUs["sth2ori"], oriU)); nln++
	*/
	if nln < 25 {
		msg := fmt.Sprintf("MalformedHeader")
		panic(errors.New(msg))
	}
	nln = 0

	stmNS := "http://rdf.biogateway.eu/prot-onto/"
	rdfNS := nss["rdf"]
	count := make(util.Set3D)

	for clsid, onemap := range duos {
		ppys := onemap["ppy"].Keys()
		if l := len(ppys); l != 1 { // unnecessary, may help debugging
			msg := fmt.Sprintf("export.Prot2go():%s: Want 1 property have: %d: %v", clsid, l, ppys)
			panic(errors.New(msg))
		}
		refs := onemap["ref"].Keys()
		/// Class level
		clsU := rdf.CompU(stmNS, clsid)
		sb.WriteString(rdf.FormT(clsU, ourUs["sub2cls"], ourUs["stm"]))
		nln++
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2lbl"], rdf.FormL(clsid)))
		nln++

		bits := strings.Split(clsid, "--")
		idL := bits[0]
		idR := bits[1]
		oriL := strings.Split(idL, "!")[1] // UP AC
		oriR := strings.Split(idR, "!")[1] // GO ID
		bgwLs := upac2bgw[oriL]["bgwp"].Keys()

		pdc := ppys[0]
		oboid := strings.Replace(oriR, "_", ":", 1)
		clsdfn := fmt.Sprintf("Association between protein %s and %s %s", oriL, gosubs[pdc], oboid)
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2dfn"], rdf.FormL(clsdfn)))
		nln++
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "predicate"), ourUs[pdc]))
		nln++

		uriR := rdf.CompU(nss["obo"], oriR)
		// multiple subjects
		for _, bgwL := range bgwLs {
			if len(bgwLs) > 1 {
				count.Add("oriL", oriL, bgwL)
			}
			uriL := rdf.CompU(nss["prot"], bgwL)
			sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "subject"), uriL))
			nln++
			sb.WriteString(rdf.FormT(uriL, ourUs[pdc], uriR))
			nln++
		}
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "object"), uriR))
		nln++
		/// Instance level
		insid := fmt.Sprintf("%s%s%s", clsid, "#", "goa")
		insU := rdf.CompU(stmNS, insid)
		sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], clsU))
		nln++
		sb.WriteString(rdf.FormT(insU, ourUs["sth2src"], srcU))
		nln++
		// metadata
		myU := rdf.CompU(nss["goa"], oriL)
		sb.WriteString(rdf.FormT(insU, ourUs["sth2ori"], myU))
		nln++
		for _, ref := range util.X1type(refs, "pubmed", "!") {
			myU := rdf.CompU(nss["pubmed"], ref)
			sb.WriteString(rdf.FormT(insU, ourUs["sth2evd"], myU))
			nln++
		}
		for _, eco := range onemap["eco"].Keys() { // for GPA files
			myU := rdf.CompU(nss["obo"], eco)
			sb.WriteString(rdf.FormT(insU, ourUs["sth2mtd"], myU))
			nln++
		}
		for _, goc := range onemap["goc"].Keys() { // for GAF files
			sb.WriteString(rdf.FormT(insU, ourUs["sth2mtd"], rdf.FormL(goc)))
			nln++
		}
	}
	wfh.Write([]byte(sb.String()))
	sb.Reset()
	return nln, nil
} // end of Prot2go

func Prot2prot(duos, upac2bgw util.Set3D, wpth string) (int, error) {
	nss := rdf.Nss // BGW URI name spaces
	keys4b := make(util.SliceSet)
	keys4b["Opys"] = []string{
		"ins2cls",
		"sth2evd",
		"sth2mtd",
		"sth2src",
		"tlp2tlp",
		"sub2cls",
		"sub2set",
	}
	keys4b["Apys"] = []string{
		"evd2lvl",
		"sth2dfn",
		"sth2lbl",
	}
	keys4b["Prns"] = []string{
		"stm",
	}
	srcU := rdf.FormU(nss["intact"])
	// prot2prot graph ini
	nln := 0
	wfh, err := os.Create(wpth)
	checkE(err)
	defer wfh.Close()
	var sb strings.Builder
	ourUs := rdf.FmtURIs(keys4b)
	header, n := rdf.Capita(keys4b)
	sb.WriteString(header)
	nln += n
	graphU := "<http://biogateway.eu/graph/prot2prot>"
	sb.WriteString(rdf.FormT(graphU, ourUs["sth2src"], srcU))
	nln++
	/*
		myori := "http://www.ebi.ac.uk/Tools/webservices/psicquic/intact/webservices/current/search/query/species:" + "9606" // TODO implement
		oriU := rdf.FormU(myori)
		sb.WriteString(rdf.FormT(graphU, ourUs["sth2ori"], oriU)); nln++
	*/
	if nln < 23 {
		msg := fmt.Sprintf("MalformedHeader")
		panic(errors.New(msg))
	}
	nln = 0

	stmNS := "http://rdf.biogateway.eu/prot-prot/"
	rdfNS := nss["rdf"]
	count := make(util.Set3D)
	for clsid, onemap := range duos {
		refs := onemap["pubids"].Keys()
		refs = util.X1type(refs, "pubmed", ":")

		clsU := rdf.CompU(stmNS, clsid)
		sb.WriteString(rdf.FormT(clsU, ourUs["sub2cls"], ourUs["stm"]))
		nln++
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2lbl"], rdf.FormL(clsid)))
		nln++
		bits := strings.Split(clsid, "--")
		idL := bits[0]
		idR := bits[1]
		oriL := strings.Split(idL, "!")[1] // UP AC
		oriR := strings.Split(idR, "!")[1] // UP AC
		clsdfn := fmt.Sprintf("Pair of molecular interactors %s and %s", oriL, oriR)
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2dfn"], rdf.FormL(clsdfn)))
		nln++
		pdc := "tlp2tlp"
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "predicate"), ourUs[pdc]))
		nln++
		bgwLs := upac2bgw[oriL]["bgwp"].Keys()
		bgwRs := upac2bgw[oriR]["bgwp"].Keys()
		// multiple subjects and objects
		// 53 human UP ACs with multiple BGW IDs
		for _, bgwL := range bgwLs {
			if len(bgwLs) > 1 {
				count.Add("oriL", oriL, bgwL)
			}
			uriL := rdf.CompU(nss["prot"], bgwL)
			sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "subject"), uriL))
			nln++
			for _, bgwR := range bgwRs {
				if len(bgwRs) > 1 {
					count.Add("oriR", oriR, bgwR)
				}
				uriR := rdf.CompU(nss["prot"], bgwR)
				sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "object"), uriR))
				nln++
				sb.WriteString(rdf.FormT(uriL, ourUs[pdc], uriR))
				nln++
				sb.WriteString(rdf.FormT(uriR, ourUs[pdc], uriL))
				nln++
			}
		}
		insid := fmt.Sprintf("%s%s%s", clsid, "#", "intact")
		insU := rdf.CompU(stmNS, insid)
		sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], clsU))
		nln++
		sb.WriteString(rdf.FormT(insU, ourUs["sth2src"], srcU))
		nln++
		/// metadata, aggregated for all subjects and objects
		/// intaracton IDs
		for key := range onemap["inacids"] {
			bits := strings.Split(key, ":")
			if bits[0] != "intact" {
				continue
			}
			myU := rdf.CompU(nss["intact"], bits[1])
			//sb.WriteString(rdf.FormT(insU, ourUs["sth2ori"], myU))
			sb.WriteString(rdf.FormT(insU, ourUs["sub2set"], myU)) // Attn: change prop
			nln++
		}
		/// publications
		// TODO use this patter for all?
		for _, item := range refs {
			myU := rdf.CompU(nss["pubmed"], item)
			sb.WriteString(rdf.FormT(insU, ourUs["sth2evd"], myU))
			nln++
		}
		/// confidence values
		for key := range onemap["cnfvals"] {
			bits := strings.Split(key, ":")
			if bits[0] != "intact-miscore" {
				continue
			}
			sb.WriteString(rdf.FormT(insU, ourUs["evd2lvl"], rdf.FormL(bits[1])))
			nln++
		}
		/// interaction types
		for key := range onemap["inactps"] {
			bits := strings.Split(key, "\"")
			if bits[0] != "psi-mi:" {
				continue
			}
			myU := rdf.CompU(nss["obo"], strings.Replace(bits[1], ":", "_", 1))
			sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], myU))
			nln++
		}
		/// detection methods
		for key := range onemap["mtds"] {
			bits := strings.Split(key, "\"")
			if bits[0] != "psi-mi:" {
				continue
			}
			myU := rdf.CompU(nss["obo"], strings.Replace(bits[1], ":", "_", 1))
			sb.WriteString(rdf.FormT(insU, ourUs["sth2mtd"], myU))
			nln++
		}
	}
	if nln == 0 {
		msg := fmt.Sprintf("export.Prot2prot():%s: NoContent", wpth)
		return nln, errors.New(msg)
	}
	wfh.Write([]byte(sb.String()))
	sb.Reset()
	return nln, nil
} // end of Prot2prot

// Tfac2gene wrtes an RDF file for relations between transcription factors (TF) and target genes (TG);
// taxonomic coverage defined by arguments 2 and 3
// Arguments:
// 1. map aggregating data from one external source
// 2. map TF ID (currently UniProt Accession) -> -> BGW protein ID
// 3. map Gene Symbol -> -> BGW gene ID
// 4. data source map label -> URI, currently a SINGLE source, one of:
// cytreg  extri  geredb  goa  htri  intact  signor  tfacts  trrust
// 5; path for writing 'tfac2gene' file
// Retturns:
// 1. number of lines written to the output RDF file
// 2. error
func Tfac2gene(dat4txn map[string]util.Set3D, upac2bgw, gsym2bgw util.Set3D, wpth string) (int, error) {
	// Note: no isoforms in this graph
	nss := rdf.Nss // BGW URI name spaces
	keys4b := make(util.SliceSet)
	keys4b["Opys"] = []string{
		"ins2cls",
		"sth2src",
		"sub2cls",
		"rgr2trg",
		"sth2evd",
	}
	keys4b["Apys"] = []string{
		"sth2dfn",
		"sth2lbl",
		"evd2lvl",
		"sth2val",
	}
	keys4b["Prns"] = []string{
		"stm",
	}
	// trrust: Activation|Repression|Unknown
	// cytreg: Activation|Repression
	// geredb: positive|negative|unknown
	// goa: UP|DOWN|GO:XXXXXXX
	// signor: UP|DOWN|Unknown
	// tfacts: UP|DOWN
	// should be 'positive' or 'negative'
	modes := map[string]string{
		"Activation": "Positive",
		"Repression": "Negative",
		"UP":         "Positive",
		"DOWN":       "Negative",
		"positive":   "Positive",
		"negative":   "Negative",
	}
	// tfac2gene graph ini
	nln := 0
	wfh, err := os.Create(wpth)
	checkE(err)
	defer wfh.Close()
	var sb strings.Builder
	ourUs := rdf.FmtURIs(keys4b)
	header, n := rdf.Capita(keys4b)
	sb.WriteString(header)
	nln += n
	graphU := "<http://biogateway.eu/graph/tfac2gene>"
	if nln < 20 {
		msg := fmt.Sprintf("MalformedHeader")
		panic(errors.New(msg))
	}
	nln = 0
	///////////////////////////////////////////////////////////////////////////////

	stmNS := "http://rdf.biogateway.eu/tfac-gene/"
	rdfNS := nss["rdf"]
	for src, duos := range dat4txn {
		uri := duos[src]["uri"].Keys()[0]
		srcU := rdf.FormU(uri)
		sb.WriteString(rdf.FormT(graphU, ourUs["sth2src"], srcU))
		nln++
		for clsid, duo := range duos {
			if clsid == src {
				continue
			}
			clsU := rdf.CompU(stmNS, clsid)
			sb.WriteString(rdf.FormT(clsU, ourUs["sub2cls"], ourUs["stm"]))
			nln++
			sb.WriteString(rdf.FormT(clsU, ourUs["sth2lbl"], rdf.FormL(clsid)))
			nln++

			bits := strings.Split(clsid, "--")
			gsymL := bits[0]
			gsymR := bits[1]
			clsdfn := fmt.Sprintf("Regulation of gene %s by transcription factor %s", gsymR, gsymL)
			sb.WriteString(rdf.FormT(clsU, ourUs["sth2dfn"], rdf.FormL(clsdfn)))
			nln++
			pdc := "rgr2trg"
			sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "predicate"), ourUs[pdc]))
			nln++                          // nln:31
			oriLs := duo["uniprot"].Keys() // UniProt canonical accessions
			//if len(oriLs) != 1 // only NFKB and AP1
			// multiple BGW genes due to multiple GeneSymbols for a single UP ACC
			bgwRs := gsym2bgw[gsymR]["bgwg"].Keys() // GeneSymbols
			if len(bgwRs) == 0 {continue}
			//if len(bgwRs) != 1 // 9606:1110
			for _, oriL := range oriLs {
				bgwLs := upac2bgw[oriL]["bgwp"].Keys()
				if len(bgwLs) == 0 {continue}
				//if len(bgwLs) = 0 // 9606:14, 13 unique; only 3 UP ACCs: P62805, P69905, Q16385
				if len(bgwLs) != 1 {
					msg := fmt.Sprintf("export.Tfac2gene():%s:%s: %d ProtIDs ", gsymL, oriL, len(bgwLs))
					fmt.Printf("%s\n", msg)
				} // 9606:25 unique accessions no BGW protein, e.g.Q9NRY4, present in idmapping
				for _, bgwL := range bgwLs {
					uriL := rdf.CompU(nss["prot"], bgwL)
					sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "subject"), uriL))
					nln++
					for _, bgwR := range bgwRs {
						uriR := rdf.CompU(nss["gene"], bgwR)
						sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "object"), uriR))
						nln++
						sb.WriteString(rdf.FormT(uriL, ourUs[pdc], uriR))
						nln++

						//for src, uri := range srcs {
						insid := fmt.Sprintf("%s%s%s", clsid, "#", src)
						insU := rdf.CompU(stmNS, insid)
						meta := "pubmed"
						keys := duo[meta].Keys() // PubMed  IDs
						if len(keys) == 0 {
							msg := fmt.Sprintf("export.Tfac2gene():%s: NoPubMedIDs ", clsid)
							fmt.Printf("%s\n", msg)
							continue
						}
						sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], clsU))
						nln++
						sb.WriteString(rdf.FormT(insU, ourUs["sth2src"], srcU))
						nln++
						// Cleaning up the mess in the data file: PubMed ID: \d+
						for _, key := range keys {
							if key[0] < 48 || key[0] > 57 {
								continue
							}
							pubmedU := rdf.CompU(nss["pubmed"], key)
							sb.WriteString(rdf.FormT(insU, ourUs["sth2evd"], pubmedU))
							nln++
						}
						meta = "confidence"
						keys = duo[meta].Keys() // confidence levels
						for _, key := range keys {
							sb.WriteString(rdf.FormT(insU, ourUs["evd2lvl"], rdf.FormL(key)))
							nln++
						}
						meta = "mode"
						keys = duo[meta].Keys() // regulation mode
						for _, key := range keys {
							val, ok := modes[key]
							if !ok {
								continue
							}
							sb.WriteString(rdf.FormT(insU, ourUs["sth2val"], rdf.FormL(val)))
							nln++
						}
						//}

					} // bgwRs
				} // bgwLs
			} // oriLs
		} // duos
	} // srcs
	wfh.Write([]byte(sb.String()))
	sb.Reset()
	return nln, nil
} // end of Tfac2gene

// Note: no isoforms in this graph
func Ortho(duos, upac2bgw util.Set3D, wpth string) (int, error) {
	nss := rdf.Nss // BGW URI name spaces
	keys4b := make(util.SliceSet)
	keys4b["Opys"] = []string{
		"orl2orl",
		"ins2cls",
		"sth2src",
		"sub2cls",
		"sub2set",
	}
	keys4b["Apys"] = []string{
		"sth2dfn",
		"sth2lbl",
	}
	keys4b["Prns"] = []string{
		"stm",
	}
	// ortho graph ini
	nln := 0
	wfh, err := os.Create(wpth)
	checkE(err)
	defer wfh.Close()
	var sb strings.Builder
	ourUs := rdf.FmtURIs(keys4b)
	header, n := rdf.Capita(keys4b)
	sb.WriteString(header)
	nln += n
	graphU := "<http://biogateway.eu/graph/ortho>"
	srcU := rdf.FormU(nss["uniprot"])
	sb.WriteString(rdf.FormT(graphU, ourUs["sth2src"], srcU))
	nln++
	if nln < 17 {
		msg := fmt.Sprintf("MalformedHeader")
		panic(errors.New(msg))
	}
	nln = 0
	///////////////////////////////////////////////////////////////////////////////
	stmNS := "http://rdf.biogateway.eu/ortho/"
	rdfNS := nss["rdf"]
	idmkeys := bgw.Orthokeys
	for clsid, duo := range duos {
		clsU := rdf.CompU(stmNS, clsid)
		bits := strings.Split(clsid, "--")
		oriL := strings.Split(bits[0], "!")[1] // UniProt Accession
		oriR := strings.Split(bits[1], "!")[1] // UniProt Accession
		bgwLs := upac2bgw[oriL]["bgwp"].Keys()
		bgwRs := upac2bgw[oriR]["bgwp"].Keys()
		if len(bgwLs) == 0 {
			msg := fmt.Sprintf("export.Ortho():%s: NoProtID", oriL)
			fmt.Printf("%s\n", msg)
			continue
		}
		if len(bgwRs) == 0 {
			msg := fmt.Sprintf("export.Ortho():%s: NoProtID", oriR)
			fmt.Printf("%s\n", msg)
			continue
		}
		sb.WriteString(rdf.FormT(clsU, ourUs["sub2cls"], ourUs["stm"]))
		nln++
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2lbl"], rdf.FormL(clsid)))
		nln++
		clsdfn := fmt.Sprintf("Pair of orthologous proteins %s and %s", oriL, oriR)
		sb.WriteString(rdf.FormT(clsU, ourUs["sth2dfn"], rdf.FormL(clsdfn)))
		nln++
		pdc := "orl2orl"
		sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "predicate"), ourUs[pdc]))
		nln++
		// multiple subjects and objects
		// 53 human UP ACs with multiple BGW IDs
		for _, bgwL := range bgwLs {
			uriL := rdf.CompU(nss["prot"], bgwL)
			sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "subject"), uriL))
			nln++
			for _, bgwR := range bgwRs {
				uriR := rdf.CompU(nss["prot"], bgwR)
				sb.WriteString(rdf.FormT(clsU, rdf.CompU(rdfNS, "object"), uriR))
				nln++
				sb.WriteString(rdf.FormT(uriL, ourUs[pdc], uriR))
				nln++
				sb.WriteString(rdf.FormT(uriR, ourUs[pdc], uriL))
				nln++
			}
		}
		// TODO add relations uriL/R memberOf setU
		for key, sets := range duo {
			src, ok := idmkeys[key]
			if !ok {continue}// needed!
			insid := fmt.Sprintf("%s%s%s", clsid, "#", src)
			insU := rdf.CompU(stmNS, insid)
			sb.WriteString(rdf.FormT(insU, ourUs["ins2cls"], clsU))
			nln++
			srcU := rdf.FormU(nss[src])
			sb.WriteString(rdf.FormT(insU, ourUs["sth2src"], srcU))
			nln++
			for setid, _ := range sets {
				prefix := ""
				if key == "OrthoDB" {
					prefix = "?query="
				}
				lastbit := fmt.Sprintf("%s%s", prefix, setid)
				setU := rdf.FormU(fmt.Sprintf("%s%s", nss[src], lastbit))
				sb.WriteString(rdf.FormT(insU, ourUs["sub2set"], setU))
				nln++
			}
		}
	}
	if nln == 0 {
		msg := fmt.Sprintf("NoContent")
		return nln, errors.New(msg)
	}
	wfh.Write([]byte(sb.String()))
	sb.Reset()
	return nln, nil
} // end of Ortho
